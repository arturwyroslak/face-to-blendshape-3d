import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
import { GLTFExporter } from 'three/examples/jsm/exporters/GLTFExporter.js';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { FaceLandmarker, FilesetResolver } from '@mediapipe/tasks-vision';
import { ARKitBlendshapeMapper } from './arkit-mapper.js';
import { FaceMeshGenerator } from './face-mesh-generator.js';
import { TextureMapper } from './texture-mapper.js';

class FaceToBlendshape3D {
    constructor() {
        this.faceLandmarker = null;
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.controls = null;
        this.faceMesh = null;
        this.headModel = null; // Store the loaded head model
        this.blendshapes = {};
        this.currentImage = null;
        this.textureCanvas = null;
        
        this.init();
    }
    
    async init() {
        await this.initMediaPipe();
        this.initThreeJS();
        this.initEventListeners();
        this.animate();
    }
    
    async initMediaPipe() {
        try {
            const vision = await FilesetResolver.forVisionTasks(
                'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm'
            );
            
            this.faceLandmarker = await FaceLandmarker.createFromOptions(vision, {\n                baseOptions: {\n                    modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/latest/face_landmarker.task',\n                    delegate: 'GPU'\n                },\n                outputFaceBlendshapes: true,\n                outputFacialTransformationMatrixes: true,\n                runningMode: 'IMAGE',\n                numFaces: 1\n            });\n            \n            this.showStatus('MediaPipe initialized successfully', 'success');\n        } catch (error) {\n            console.error('MediaPipe initialization error:', error);\n            this.showStatus('Failed to initialize MediaPipe: ' + error.message, 'error');\n        }\n    }\n    \n    initThreeJS() {\n        const canvas = document.getElementById('canvas3d');\n        const container = canvas.parentElement;\n        \n        // Scene\n        this.scene = new THREE.Scene();\n        this.scene.background = new THREE.Color(0xf8f9ff);\n        \n        // Camera\n        this.camera = new THREE.PerspectiveCamera(\n            45,\n            container.clientWidth / container.clientHeight,\n            0.1,\n            1000\n        );\n        this.camera.position.z = 2;\n        \n        // Renderer\n        this.renderer = new THREE.WebGLRenderer({ canvas, antialias: true, preserveDrawingBuffer: true });\n        this.renderer.setSize(container.clientWidth, container.clientHeight);\n        this.renderer.setPixelRatio(window.devicePixelRatio);\n        \n        // Controls\n        this.controls = new OrbitControls(this.camera, canvas);\n        this.controls.enableDamping = true;\n        this.controls.dampingFactor = 0.05;\n        \n        // Lights\n        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);\n        this.scene.add(ambientLight);\n        \n        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\n        directionalLight.position.set(0, 1, 1);\n        this.scene.add(directionalLight);\n        \n        const backLight = new THREE.DirectionalLight(0xffffff, 0.3);\n        backLight.position.set(0, 0, -1);\n        this.scene.add(backLight);\n        \n        // Load Head Model\n        const loader = new GLTFLoader();\n        loader.load('./head.glb', (gltf) => {\n            this.headModel = gltf.scene;\n            // Center the loaded model\n            const box = new THREE.Box3().setFromObject(this.headModel);\n            const center = box.getCenter(new THREE.Vector3());\n            this.headModel.position.sub(center);\n            \n            this.scene.add(this.headModel);\n            this.headModel.visible = false; // Hide until processing\n            console.log('Head model loaded');\n        }, undefined, (error) => {\n            console.error('An error occurred loading the head model:', error);\n        });\n\n        // Handle resize\n        window.addEventListener('resize', () => this.onResize());\n    }\n    \n    initEventListeners() {\n        const uploadArea = document.getElementById('uploadArea');\n        const fileInput = document.getElementById('fileInput');\n        const processBtn = document.getElementById('processBtn');\n        const exportBtn = document.getElementById('exportBtn');\n        \n        uploadArea.addEventListener('click', () => fileInput.click());\n        \n        uploadArea.addEventListener('dragover', (e) => {\n            e.preventDefault();\n            uploadArea.classList.add('dragover');\n        });\n        \n        uploadArea.addEventListener('dragleave', () => {\n            uploadArea.classList.remove('dragover');\n        });\n        \n        uploadArea.addEventListener('drop', (e) => {\n            e.preventDefault();\n            uploadArea.classList.remove('dragover');\n            const file = e.dataTransfer.files[0];\n            if (file && file.type.startsWith('image/')) {\n                this.loadImage(file);\n            }\n        });\n        \n        fileInput.addEventListener('change', (e) => {\n            const file = e.target.files[0];\n            if (file) {\n                this.loadImage(file);\n            }\n        });\n        \n        processBtn.addEventListener('click', () => this.processImage());\n        exportBtn.addEventListener('click', () => this.exportGLB());\n    }\n    \n    loadImage(file) {\n        const reader = new FileReader();\n        reader.onload = (e) => {\n            const preview = document.getElementById('preview');\n            preview.src = e.target.result;\n            preview.style.display = 'block';\n            \n            const img = new Image();\n            img.onload = () => {\n                this.currentImage = img;\n                document.getElementById('processBtn').disabled = false;\n                this.showStatus('Image loaded. Ready to process.', 'success');\n            };\n            img.src = e.target.result;\n        };\n        reader.readAsDataURL(file);\n    }\n    \n    async processImage() {\n        if (!this.currentImage || !this.faceLandmarker) return;\n        \n        try {\n            document.getElementById('processBtn').disabled = true;\n            document.getElementById('processBtnText').innerHTML = '<span class=\"spinner\"></span> Processing...';\n            this.showStatus('Detecting face landmarks...', 'loading');\n            \n            // Detect face\n            const results = this.faceLandmarker.detect(this.currentImage);\n            \n            if (!results.faceLandmarks || results.faceLandmarks.length === 0) {\n                throw new Error('No face detected in the image');\n            }\n            \n            const landmarks = results.faceLandmarks[0];\n            const blendshapes = results.faceBlendshapes?.[0]?.categories || [];\n            const transformMatrix = results.facialTransformationMatrixes?.[0];\n            \n            // Map to ARKit blendshapes\n            const mapper = new ARKitBlendshapeMapper();\n            this.blendshapes = mapper.mapMediaPipeToARKit(blendshapes, landmarks);\n            \n            // Generate texture from image\n            this.showStatus('Generating face texture...', 'loading');\n            const textureMapper = new TextureMapper();\n            this.textureCanvas = textureMapper.createFaceTexture(this.currentImage, landmarks);\n            \n            // Generate 3D mesh with morph targets\n            this.showStatus('Generating 3D model with morph targets...', 'loading');\n            const meshGenerator = new FaceMeshGenerator();\n            this.faceMesh = meshGenerator.generateWithMorphTargets(\n                landmarks,\n                this.blendshapes,\n                transformMatrix,\n                this.textureCanvas\n            );\n            \n            // Clear previous mesh\n            const oldMesh = this.scene.getObjectByName('faceMesh');\n            if (oldMesh) {\n                this.scene.remove(oldMesh);\n            }\n            \n            // Add new mesh\n            this.faceMesh.name = 'faceMesh';\n            this.scene.add(this.faceMesh);\n            \n            // Fit Head Model to Face Mesh\n            if (this.headModel) {\n                this.headModel.visible = true;\n                \n                // 1. Calculate Face Mesh Dimensions\n                this.faceMesh.geometry.computeBoundingBox();\n                const faceBox = this.faceMesh.geometry.boundingBox;\n                const faceWidth = faceBox.max.x - faceBox.min.x;\n                const faceHeight = faceBox.max.y - faceBox.min.y;\n                const faceCenter = faceBox.getCenter(new THREE.Vector3());\n                \n                // 2. Calculate Head Model Dimensions (Base State)\n                // Reset transforms first to get true size\n                this.headModel.scale.set(1, 1, 1);\n                this.headModel.rotation.set(0, 0, 0);\n                this.headModel.updateMatrixWorld(true);\n                \n                const headBox = new THREE.Box3().setFromObject(this.headModel);\n                const headWidth = headBox.max.x - headBox.min.x;\n                const headHeight = headBox.max.y - headBox.min.y;\n                const headDepth = headBox.max.z - headBox.min.z;\n                \n                // 3. Calculate Scale Factors\n                // We assume the face covers roughly 70% of the head width (ear-to-ear is wider than face mesh)\n                // and roughly 60% of height.\n                // These factors need tuning based on the specific head.glb asset.\n                const targetHeadWidth = faceWidth * 1.5; \n                const targetHeadHeight = faceHeight * 1.8;\n                \n                const scaleX = targetHeadWidth / headWidth;\n                const scaleY = targetHeadHeight / headHeight;\n                \n                // Apply scale (Use max to ensure head covers face)\n                const uniformScale = Math.max(scaleX, scaleY);\n                // Allow some non-uniformity if requested, but uniform looks safer initially.\n                // User asked for \"automatic widening/heightening\", so let's try non-uniform if needed, \n                // but usually uniform is better to preserve head shape.\n                // Let's stick to a slightly non-uniform approach to fit contact points best.\n                this.headModel.scale.set(scaleX, scaleY, uniformScale); \n                \n                // 4. Position Head Model\n                // Align centers\n                const newHeadBox = new THREE.Box3().setFromObject(this.headModel);\n                const newHeadCenter = newHeadBox.getCenter(new THREE.Vector3());\n                \n                // Offsets: \n                // X: Align centers\n                const offsetX = faceCenter.x - newHeadCenter.x;\n                // Y: Align centers\n                const offsetY = faceCenter.y - newHeadCenter.y;\n                // Z: Head should be slightly behind face.\n                // Face is at Z ~ 0 to 0.5 (or -0.5 to 0.5 depending on gen).\n                // Head center is likely inside the head.\n                // We want the front surface of head to touch back of face.\n                // Let's align center Z first, then push back.\n                const offsetZ = faceCenter.z - newHeadCenter.z - (headDepth * uniformScale * 0.1); \n                \n                this.headModel.position.add(new THREE.Vector3(offsetX, offsetY, offsetZ));\n                \n                // Adjust order\n                this.faceMesh.renderOrder = 1;\n                this.headModel.renderOrder = 0;\n            }\n            \n            // Display blendshapes\n            this.displayBlendshapes();\n            \n            document.getElementById('exportBtn').disabled = false;\n            this.showStatus('3D model with texture and morph targets generated!', 'success');\n        } catch (error) {\n            console.error('Processing error:', error);\n            this.showStatus('Error: ' + error.message, 'error');\n        } finally {\n            document.getElementById('processBtn').disabled = false;\n            document.getElementById('processBtnText').textContent = 'Process Image';\n        }\n    }\n    \n    displayBlendshapes() {\n        const panel = document.getElementById('blendshapesPanel');\n        const list = document.getElementById('blendshapesList');\n        \n        list.innerHTML = '';\n        \n        Object.entries(this.blendshapes)\n            .filter(([name, value]) => value > 0.01)\n            .sort((a, b) => b[1] - a[1])\n            .forEach(([name, value]) => {\n                const item = document.createElement('div');\n                item.className = 'blendshape-item';\n                item.innerHTML = `\n                    <span class=\"blendshape-name\">${name}</span>\n                    <span class=\"blendshape-value\">${(value * 100).toFixed(1)}%</span>\n                `;\n                list.appendChild(item);\n            });\n        \n        panel.style.display = 'block';\n    }\n    \n    async exportGLB() {\n        if (!this.faceMesh) return;\n        \n        try {\n            document.getElementById('exportBtn').disabled = true;\n            this.showStatus('Exporting GLB with texture and morph targets...', 'loading');\n            \n            const exporter = new GLTFExporter();\n            \n            // Export options\n            const options = {\n                binary: true,\n                maxTextureSize: 2048,\n                embedImages: true,\n                truncateDrawRange: false\n            };\n            \n            // Create a group to export both\n            const exportGroup = new THREE.Group();\n            exportGroup.add(this.faceMesh.clone());\n            if (this.headModel && this.headModel.visible) {\n                exportGroup.add(this.headModel.clone());\n            }\n            \n            // Export to GLB\n            exporter.parse(\n                exportGroup,\n                (result) => {\n                    if (result instanceof ArrayBuffer) {\n                        this.saveArrayBuffer(result, 'face-model-blendshapes.glb');\n                        this.showStatus('GLB model exported successfully!', 'success');\n                    }\n                },\n                (error) => {\n                    console.error('Export error:', error);\n                    this.showStatus('Export failed: ' + error.message, 'error');\n                },\n                options\n            );\n        } catch (error) {\n            console.error('Export error:', error);\n            this.showStatus('Export failed: ' + error.message, 'error');\n        } finally {\n            document.getElementById('exportBtn').disabled = false;\n        }\n    }\n    \n    saveArrayBuffer(buffer, filename) {\n        const blob = new Blob([buffer], { type: 'application/octet-stream' });\n        const url = URL.createObjectURL(blob);\n        const link = document.createElement('a');\n        link.href = url;\n        link.download = filename;\n        link.click();\n        URL.revokeObjectURL(url);\n    }\n    \n    showStatus(message, type) {\n        const status = document.getElementById('status');\n        status.textContent = message;\n        status.className = `status ${type}`;\n        status.style.display = 'block';\n        \n        if (type === 'success') {\n            setTimeout(() => {\n                status.style.display = 'none';\n            }, 3000);\n        }\n    }\n    \n    onResize() {\n        const container = this.renderer.domElement.parentElement;\n        this.camera.aspect = container.clientWidth / container.clientHeight;\n        this.camera.updateProjectionMatrix();\n        this.renderer.setSize(container.clientWidth, container.clientHeight);\n    }\n    \n    animate() {\n        requestAnimationFrame(() => this.animate());\n        this.controls.update();\n        this.renderer.render(this.scene, this.camera);\n    }\n}\n\n// Initialize app\nnew FaceToBlendshape3D();